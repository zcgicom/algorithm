package com.itcat.Thread;
/**
 * 什么是线程安全？
 *      1.多线程环境下
 *      2.对该对象的访问不需要额外添加同步控制
 *      3.操作的数据结果依然正确
 *      一个专业的描述：当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以
 * 获得正确的结果，我们就说这个对象是线程安全的
 *
 * 什么时候考虑线程安全？
 *      1.多个线程同时访问同一个资源时，考虑线程安全
 *      2.资源是有状态的，比如我们所说的字符串拼接，这个时候数据会有变化(读取数据时是无状态的)
 *
 * 如何做到线程安全？
 *      实现线程安全的方式有多种，其中在源码中常见的方式是采用synchronized关键字给代码块或方法加锁
 *
 * StringBuffer的每个方法都加了Synchronized关键字实现线程安全
 * 开发中，如果需要拼接字符串，是有StringBuffer还是StringBuilder？
 *      场景一：如果是多个线程访问同一个资源，那么就需要上锁，才能保证数据的安全性。这个时候如果使用的是非线程安全的对象，比如StringBuilder，那么
 * 就需要加锁(使用synchronized关键字)
 *      场景二：如果每个线程访问的是各自的资源，那么就不需要考虑线程安全的问题，所以这个时候我们可以放心使用非线程安全的对象，比如StringBuilder
 *      实际场景：字符拼接问题：stringBuilder.append("");
 *          1.调用方法
 *          2.方法内创建StringBuilder对象
 *          每一次方法请求，相当于创建了一个线程(每个方法占用独立的一块空间，线程之间互不干扰)
 *      具体而言就是，如果我们是在方法中使用的非线程安全的对象(如StringBuilder)，那么就相当于每个线程独立占有一个StringBuilder对象，不存在多个线程
 * 共享一个资源的情况，也就不存在线程安全的问题，可以放心使用！
 *
 * 通常的书写方式是在方法内书写该拼接方法：
 * 方法内:
 *      //由于方法会在栈中都是私有占有栈内存，因此多个线程分别对应一个资源，所以使用该方式不存在线程不安全的问题
 *      //换句话说，多个线程对应一个资源时是线程不安全，一个线程对应一个资源时是线程安全的(不是共享的资源不会存在线程安全)，
 *      //也就是说每个线程访问一个StringBuilder方法
 *      //ArrayList、HashMap也是这样用
 *
 *      StringBuilder sb = new StringBuilder();
 *      sb.append("");
 */
public class TestThreadSecrity {
}
