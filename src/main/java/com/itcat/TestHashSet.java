package com.itcat;

/**
 * 14-HashSet
 *
 * HashSet的存储原理，主要是如何保证唯一性！
 * JDK1.7版本：
 *      1.为什么要采用Hash算法？有什么优势，能解决什么问题？
 *
 *      2.所谓的哈希表是一张什么表？
 *          -1. 哈希表的本质是一个数组，而其中的元素是链表
 *          -2. 新加入链表的元素的.next指向前一个元素
 *      3.HashSet如何保证保存对象的唯一性？回京了一个什么样的运算过程？
 *          -1. 首先，需要明确的一点，HashSet底层采用的是HashMap实现存储，其值作为HashMap的Key
 *          -2. 由于HashMap的底层是采用数组的形式存储数据，当添加数据时需要保证数据的唯一性
 *          -3. 如果采用逐个遍历的方式，则效率低下，尤其是在数据很多的情况下更是如此
 *          -4. 所以为了解决效率问题，采用Hash算法，通过计算对象的hashcode，然后进行hash值 & 数组长度 - 1的位运算，得到存储在数组的那个下标下
 *          -5. 如果在此时计算的位置处，不存在元素，则直接存储，不用比较
 *          -6. 哈希冲突 -- 如果不同对象计算出的hash值是相同的，则采用equals方法进行比较，如果比较相等，则不插入，否则形成链表
 *
 * JDK1.8版本：
 *      1.相对于JDK1.7版本，JDK1.8版本做出了一些优化。
 *      2.随着元素不断增加，链表可能会越来越长，遍历的效率逐渐下降，因此在链表长度和数组长度超过其阈值时，会将链表转换为红黑树，提升查询效率。
 */
public class TestHashSet {
}
